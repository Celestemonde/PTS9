#!/usr/bin/env python
# -*- coding: utf8 -*-
# *****************************************************************
# **       PTS -- Python Toolkit for working with SKIRT          **
# **       Â© Astronomical Observatory, Ghent University          **
# *****************************************************************

## \package pts.simulation.simulation Representing the files related to a SKIRT simulation
#
# An instance of the Simulation class in this module represents all input and output files
# related to a single performed SKIRT simulation.

# -----------------------------------------------------------------

import os
import pts.utils.path

# -----------------------------------------------------------------

## This function returns a list of Simulation objects corresponding to SKIRT output in the specified directory,
# optionally restricted to the simulation with the specified prefix. The function detects SKIRT output based on
# the primary log file generated by each simulation. The arguments are as follows.
#  - \em outDirPath: path to the directory to be searched, specified as a string or a pathlib.Path object.
#    The path may be absolute, relative to a user's home folder, or relative to the current working directory.
#    A missing argument or the empty string indicates the current working directory.
#  - \em prefix: if specified, the search is restricted to the simulation with the specified prefix (corresponding
#    to the stem of the ski filename passed to SKIRT). If omitted or None, all simulations in the directory are
#    included.
#
# If no simulation output conforming to the specified requirements is found, the function returns an empty list.
# The Simulation objects created by this function have no knowledge about any of the input files of the simulation.
#
def createSimulations(outDirPath="", prefix=None):
    simulations = []

    # loop over the log files in the specified directory
    for logfile in pts.utils.path.absolute(outDirPath).glob("*_log.txt"):
        if prefix is None or prefix == logfile.stem[:-4]:
            simulations += [ Simulation(outDirPath=logfile.parent, prefix=logfile.stem[:-4]) ]

    return simulations

## This function returns a single Simulation object corresponding to SKIRT output in the specified directory,
# optionally restricted to the simulation with the specified prefix. The function calls the createSimulations()
# function, verifies that there is exactly one item in the returned list, and returns that item. If no simulation
# is found, or multiple simulations are found, the function raises an error.
#
def createSimulation(outDirPath="", prefix=None):
    simulations = createSimulations(outDirPath, prefix)
    if len(simulations) == 0:
        raise ValueError("No simulations were found for the specified directory and prefix")
    elif len(simulations) > 1:
        raise ValueError("Multiple simulations were found for the specified directory and prefix")
    return simulations[0]

# -----------------------------------------------------------------

## An instance of the Simulation class represents all input and output files related to a single performed
# SKIRT simulation. To create an instance of the class, one specifies the name of the ski file (used as prefix
# for all output filenames) plus directory paths for the input and output files.
# The methods of the class allow retrieving all kinds of information about the simulation results.
#
# The code in this class uses ad-hoc knowledge about SKIRT's data formats and naming schemes; for example:
#  - SKIRT's hard-coded output file names are used to locate various output files.
#  - the structure of the SKIRT parameter file (ski file) is used to determine things like
#    the names of the instruments and probes in the simulation.
#  - the format of the log file is used to extract success or error messages.
#
class Simulation():

    ## The constructor accepts the following arguments:
    # - \em prefix: the name of the ski file for which the simulation was performed (without the directory path and
    #   without the \c .ski filename extension) and which has been used as a prefix for all output file names.
    #   If the prefix argument is empty or missing, the skiFilePath argument must be provided so that the prefix
    #   can be automatically derived from the (stem of the name of) the specified ski file.
    # - \em skiFilePath: the path of the input ski file for which the simulation was performed (\em not the
    #   \c parameters.xml file generated by SKIRT). This argument is optional, but if it is omitted, the prefix
    #   argument must be present and non-empty.
    # - \em inDirPath: the input path of the simulation. If there were no input files for the simulation, or if
    #   access to the input files is not needed, this argument may be omitted.
    # - \em outDirPath: the output path of the simulation. If this argument is missing, the output path is taken to
    #   be the current working directory.
    # - \em process: optional subprocess.Popen object that can be queried for completion of a simulation.
    #   If the argument is not provided, the completion status is derived from the log file.
    #   This argument is provided by the Skirt object when it creates a Simulation instance for a simulation
    #   that is being performed in asynchronous mode.
    #
    # All paths described above may be specified as a string or as a pathlib.Path object. The path may be absolute,
    # relative to a user's home folder, or relative to the current working directory.
    #
    def __init__(self, prefix="", *, skiFilePath=None, inDirPath=None, outDirPath="", process=None):

        if len(prefix)==0 and skiFilePath is None:
            raise ValueError("Simulation constructor must specify prefix or ski file path")

        # remember the absolute paths and the prefix
        self._skiFilePath = pts.utils.path.absolute(skiFilePath) if skiFilePath is not None else None
        self._inDirPath = pts.utils.path.absolute(inDirPath) if inDirPath is not None else None
        self._outDirPath = pts.utils.path.absolute(outDirPath)
        self._prefix = prefix if len(prefix)>0 else self._skiFilePath.stem

        # remember the process, if provided, and its completion status
        self._process = process
        self._running = 'true' if process is not None else 'unknown'

        # provide placeholders for caching frequently-used objects
        self._parameters = None
        self._units = None

    ## This function returns the prefix for the simulation, which is used for all output file names.
    def prefix(self):
        return self._prefix

    ## This function returns the absolute file path of the input ski file for which the simulation was performed
    # (not the \c parameters.xml file generated by SKIRT), or None if it is unknown.
    def skiFilePath(self):
        return self._skiFilePath

    ## This function returns the absolute path to the input directory of the simulation, or None if it is unknown.
    def inDirPath(self):
        return self._inDirPath

    ## This function returns the absolute path to the output directory of the simulation.
    def outDirPath(self):
        return self._outDirPath

    ## This function returns the absolute path for a simulation input file, given the file's name,
    # or None if the input directory path is unknown.
    def inFilePath(self, name):
        if self._inDirPath is not None:
            return self._inDirPath / name
        else:
            return None

    ## This function returns the absolute path for a simulation output file, given the file's partial name
    # (the partial name does not include the prefix and the subsequent underscore).
    def outFilePath(self, partialname):
        return self._outDirPath / (self._prefix + "_" + partialname)

    ## This function returns the absolute path for the simulation log file.
    def logFilePath(self):
        return self.outFilePath("log.txt")

    # -----------------------------------------------------------------

    ## This function returns the status of the simulation, based on its process completion state (if available)
    # and the contents of its log file, as one of the following strings:
    #  - 'NotStarted': the simulation has not (yet) been started.
    #  - 'Running': the simulation is still running, or at least it seems to be so (for example, the simulation
    #    crashed without logging an error message and the Simulation was constructed without a project object).
    #  - 'Crashed': the simulation ended with a fatal error.
    #  - 'Finished': the simulation completed properly.
    def status(self):

        # if we were given a process object, and we still have it, query it
        if self._process is not None:
            if self._process.poll() is None:
                return "Running"
            else:
                # allow the process object to be freed
                self._process = None
                self._running = 'false'

        # the process has finished (running==false) or we weren't given a process object (running==unknown)

        # handle log file not found
        logpath = self.logFilePath()
        if not logpath.is_file():
            return "NotStarted"

        # get the last two lines of the file (assume the relevant portion is not longer than 500 characters)
        with open(logpath, 'rb') as logfile:
            logfile.seek(0, os.SEEK_END)
            logfile.seek(-min(logfile.tell(),500), os.SEEK_END)
            chunk = logfile.read()
        lines = chunk.splitlines()
        last = lines[-1] if len(lines)>0 else ""
        lastbutone = lines[-2] if len(lines)>1 else ""

        # handle contents of the last lines
        if " Available memory: " in last: last = lastbutone
        if " Finished simulation " + self._prefix in last: return "Finished"
        if " *** Error: " in last: return "Crashed"
        if self._running == 'false': return "Crashed"
        return "Running"   # we don't know for sure, but we can hope

    # -----------------------------------------------------------------


    # ## This function returns a SkiFile object representing the parameter file for this simulation.
    # def parameters(self):
    #     if self._parameters is None:
    #         self._parameters = SkiFile(self.ski_path)
    #     return self._parameters
    #
    # ## This function returns a Units object representing the default SKIRT units for this simulation.
    # def units(self):
    #     if self._units is None:
    #         self._units = self.parameters().units()
    #     return self._units
    #
    # ## This function allows invoking any SkiFile or SkirtUnits function directly on a simulation object. For example,
    # # self.instrumentshape() is automatically translated to self.parameters().instrumentshape(); and
    # # self.convert() is automatically translated to self.units().convert().
    # def __getattr__(self, attrname):
    #     # if this is not a system attribute
    #     if not attrname.startswith("__"):
    #         # attempt delegating to our SkiFile object
    #         try: return getattr(self.parameters(), attrname)
    #         except AttributeError: pass
    #         # attempt delegating to our SkirtUnits object
    #         try: return getattr(self.units(), attrname)
    #         except AttributeError: pass
    #     raise AttributeError("Can't delegate this attribute")
    #
    # # -----------------------------------------------------------------
    #
    # ## This function returns a list of absolute filepaths for all log files produced by the simulation, including
    # # the master log file and any log files produced by parallel (MPI) processes. The list includes only paths for
    # # log files that actually exist, and the paths are listed in order of process rank.
    # def logfilepaths(self):
    #     logname = self._prefix + "_log"
    #     logfiles = sorted(filter(lambda fn: fn.startswith(logname), arch.listdir(self._outpath,".txt")))
    #     return [ os.path.join(self._outpath, logfile) for logfile in logfiles ]
    #
    # ## This function returns a list of absolute filepaths for all "total.fits" files produced by the simulation,
    # # in the same order as the corresponding instruments occur in the ski file.
    # def totalfitspaths(self):
    #     return [ self.outfilepath(name + "_total.fits") for name in self.parameters().instrumentnames() \
    #          if arch.isfile(self.outfilepath(name + "_total.fits")) ]
    #
    # ## This function returns a list of absolute filepath tuples for all sets of "stokes*.fits" files
    # # produced by the simulation, in the same order as the corresponding instruments occur in the ski file.
    # # Each returned tuple includes the four files paths corresponding to the components of the Stokes vector,
    # # i.e. ("total.fits", "stokesQ.fits", "stokesU.fits", "stokesV.fits"), in that order.
    # def stokesfitspaths(self):
    #     return [ ( self.outfilepath(name + "_total.fits"),
    #                self.outfilepath(name + "_stokesQ.fits"),
    #                self.outfilepath(name + "_stokesU.fits"),
    #                self.outfilepath(name + "_stokesV.fits") ) for name in self.parameters().instrumentnames() \
    #          if arch.isfile(self.outfilepath(name + "_stokesQ.fits")) ]
    #
    # ## This function returns a list of absolute filepaths for all "sed.dat" files produced by the simulation,
    # # in the same order as the corresponding instruments occur in the ski file.
    # def seddatpaths(self):
    #     return [ self.outfilepath(name + "_sed.dat") for name in self.parameters().instrumentnames() \
    #          if arch.isfile(self.outfilepath(name + "_sed.dat")) ]
    #
    # ## This function returns a list of absolute filepaths for all "gridxx.dat" files produced by the simulation,
    # # in the order xy, xz, yz, xyz.
    # def gridxxdatpaths(self):
    #     return [ self.outfilepath(candidate) for candidate in \
    #                             ("ds_gridxy.dat", "ds_gridxz.dat", "ds_gridyz.dat", "ds_gridxyz.dat") \
    #              if arch.isfile(self.outfilepath(candidate)) ]
    #
    # # -----------------------------------------------------------------
    #
    # ## This function returns an appropriate axis label for the flux described in the simulation output sed files,
    # # including a description of the physical quantity and the corresponding units. If there are no sed output files,
    # # or if the units are not recognized, the function returns the string "Flux".
    # def fluxlabel(self):
    #     # get the paths of the sed output files
    #     sedpaths = self.seddatpaths()
    #     if len(sedpaths)>0:
    #         # get the second line of the file, which contains the description of the flux column
    #         sedfile = arch.opentext(sedpaths[0])
    #         sedfile.readline()
    #         fluxdescription = sedfile.readline()
    #         sedfile.close()
    #         # select the appropriate label based on the units given in the description
    #         if "(W/m2)" in fluxdescription: return r"$\lambda\,F_\lambda\,(\mathrm{W}\,\mathrm{m}^{-2})$"
    #         if "(W/m3)" in fluxdescription: return r"$F_\lambda\,(\mathrm{W}\,\mathrm{m}^{-3})$"
    #         if "(W/m2/micron)" in fluxdescription: return r"$F_\lambda\,(\mathrm{W}\,\mathrm{m}^{-2}\,\mu \mathrm{m}^{-1})$"
    #         if "(W/m2/Hz)" in fluxdescription: return r"$F_\nu\,(\mathrm{W}\,\mathrm{m}^{-2}\,\mathrm{Hz}^{-1})$"
    #         if "(Jy)" in fluxdescription: return r"$F_\nu\,(\mathrm{Jy})$"
    #     # failed
    #     return "Flux"
    #
    # # -----------------------------------------------------------------
    #
    # ## This function retrieves a field from the specified simulation text output file, and returns its value
    # # converted to the specified units. The field is located by a trigger (a text string that must occur on a line
    # # before the one containing the field) and a header (a text string that must occur on the line containing
    # # the field). The last text segment on the line represents the units of the value in the file, and the segment
    # # before the units represents the value itself. The value is converted from the units in the file to the
    # # requested units. If the function can't locate the field, it returns -1.
    # def getfieldfromfile(self, filesuffix, trigger, header, units=None):
    #     filepath = self.outfilepath(filesuffix)
    #     if arch.isfile(filepath):
    #         triggered = False
    #         for line in arch.opentext(filepath):
    #             if trigger in line: triggered = True
    #             if triggered and header in line:
    #                 segments = line.split()
    #                 if len(segments)>2:
    #                     if units!=None:
    #                         return self.units().convert(segments[-2], from_unit=segments[-1], to_unit=units)
    #                     else:
    #                         return float(segments[-1])
    #     return -1
    #
    # ## This function returns the total dust mass in the simulation's configuration space, in solar masses.
    # # The function retrieves the 'expected' dust mass value listed in the convergence check data file.
    # # It raises an error if the convergence check data file is not available or if the dust mass is zero.
    # def dustmass(self):
    #     result = self.getfieldfromfile("ds_convergence.dat", "total dust mass", "expected value", "Msun")
    #     if result < 0: raise ValueError("Can't determine dust mass")
    #     return result
    #
    # ## This function returns the total dust mass in the simulation's dust grid, in solar masses.
    # # The function retrieves the 'actual' dust mass value listed in the convergence check data file.
    # # It raises an error if the convergence check data file is not available or if the dust grid mass is zero.
    # def dustgridmass(self):
    #     result = self.getfieldfromfile("ds_convergence.dat", "total dust mass", "actual value", "Msun")
    #     if result < 0: raise ValueError("Can't determine dust grid mass")
    #     return result
    #
    # ## This function returns the total mass of the cold gass represented by the set of SPH particles imported for
    # # the simulation, in solar masses. The function retrieves this information from the log file entry
    # # written by the SPH dust distribution. It raises an error if this entry is not found.
    # def coldgasmass(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH gas", "Total gas mass", "Msun")
    #     if result < 0: raise ValueError("Can't determine SPH cold gas mass")
    #     return result
    #
    # ## This function returns the total mass of the metallic gas represented by the set of SPH particles imported for
    # # the simulation, in solar masses. The function retrieves this information from the log file entry
    # # written by the SPH dust distribution. It raises an error if this entry is not found.
    # def metallicgasmass(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH gas", "Total metal mass", "Msun")
    #     if result < 0: raise ValueError("Can't determine SPH metallic gas mass")
    #     return result
    #
    # ## This function returns the number of "cold" SPH gas particles imported for the simulation, i.e. the gas
    # # particles that actually contain dust. The function retrieves this information from the log file entry
    # # written by the SPH dust distribution. It raises an error if this entry is not found.
    # def coldgasparticles(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH gas", "gas particles containing dust")
    #     if result < 0: raise ValueError("Can't determine SPH cold gas particles")
    #     return int(result)
    #
    # ## This function returns the total initial stellar mass (i.e. the mass at the time of birth) represented by
    # # the set of SPH particles imported for the simulation, in solar masses. The function retrieves this information
    # # from the log file entry written by the SPH stellar component. It raises an error if this entry is not found or
    # # if the mass is zero.
    # def initialstellarmass(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH star", " mass:", "Msun")
    #     if result < 0: raise ValueError("Can't determine SPH initial stellar mass")
    #     return result
    #
    # ## This function returns the total mass in hii regions represented by the set of SPH particles imported for
    # # the simulation, in solar masses. The function retrieves this information from the log file entry written
    # # by the SPH starburst component. It raises an error if this entry is not found or if the mass is zero.
    # def hiiregionmass(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH HII region", " mass:", "Msun")
    #     if result < 0: raise ValueError("Can't determine SPH HII region mass")
    #     return result
    #
    # ## This function returns the total luminosity represented by the set of SPH stellar particles imported for
    # # the simulation, in solar bolometric luminosity units. The function retrieves this information from the
    # # log file entry written by the SPH stellar component. It raises an error if this entry is not found or if
    # # the total stellar luminosity is zero.
    # def stellarluminosity(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH star", " luminosity:", "Lsun")
    #     if result < 0: raise ValueError("Can't determine SPH stellar luminosity")
    #     return result
    #
    # ## This function returns the total luminosity represented by the set of SPH HII region particles imported for
    # # the simulation, in solar bolometric luminosity units. The function retrieves this information from the
    # # log file entry written by the SPH starburst component. It raises an error if this entry is not found or if
    # # the total stellar luminosity is zero.
    # def hiiregionluminosity(self):
    #     result = self.getfieldfromfile("log.txt", "Reading SPH HII region", " luminosity:", "Lsun")
    #     if result < 0: raise ValueError("Can't determine SPH HII region luminosity")
    #     return result
    #
    # # -----------------------------------------------------------------
    #
    # ## This function returns a tuple with three relevant properties of the dust grid used in the simulation:
    # # the total number of dust cells, the largest optical depth for any one cell, and the optical depth
    # # at the 90% percentile point (i.e. 90% of the cells that actually contain dust have an optical depth below
    # # this value). The function retrieves this information from the dust cell properties data file optionally
    # # written by the dust system. It raises an error if this file is not found.
    # def dustcellstats(self):
    #     # load the optical depths from the file
    #     filepath = self.outfilepath("ds_cellprops.dat")
    #     depths = np.loadtxt(arch.opentext(filepath), usecols=(8,))
    #     # calculate and return the statistics
    #     nonzerodepths = depths[depths>0]
    #     if len(nonzerodepths) > 0:
    #         return ( len(depths), np.amax(nonzerodepths), np.percentile(nonzerodepths, 90) )
    #     else:
    #         return ( len(depths), 0, 0 )
    #
    # # -----------------------------------------------------------------
    #
    # ## This function returns a numpy array with the wavelengths used by the simulation, if available.
    # # The wavelengths are given in micron, and are sorted in increasing order.
    # # For an oligochromatic simulation, the wavelengths are obtained from the ski file.
    # # For a panchromatic simulation, the wavelengths are read from the "wavelength.dat" file optionally
    # # written by the WavelengthGrid class, or from one of the "sed.dat" files written by instruments.
    # # If none of these files is present, the function raises an error.
    # def wavelengths(self):
    #     # first try the ski file (for oligochromatic simulations)
    #     result = self.parameters().wavelengths()
    #     if len(result) > 0: return np.sort(result)
    #
    #     # if that fails, try an SED data file or the wavelengths data file
    #     sedpaths = self.seddatpaths()
    #     if len(sedpaths) > 0:
    #         filepath = sedpaths[0]
    #     else:
    #         filepath = self.outfilepath("wavelengths.dat")
    #     if arch.isfile(filepath):
    #         result = np.loadtxt(arch.opentext(filepath), usecols=(0,))
    #         if len(result) > 0:
    #             return self.units().convert(result, to_unit='micron', quantity='wavelength')
    #
    #     # if everything fails, raise an error
    #     raise ValueError("Can't determine wavelengths for simulation")
    #
    # ## This function returns a list of the frame indices (in the simulation output fits files) corresponding
    # # to each of the wavelengths in the specified list (expressed in micron). The function searches the simulation's
    # # wavelength grid for the wavelength nearest to the requested value. It raises an error if the simulation
    # # wavelengths are not available.
    # def frameindices(self, wavelengths):
    #     # get the wavelength grid
    #     grid = self.wavelengths()
    #     # loop over the specified wavelengths
    #     return [ np.argmin(np.abs(grid-wave)) for wave in wavelengths ]
    #
    # ## This function returns a numpy array representing the wavelength grid used by the simulation, including both
    # # the wavelength bin centers and the corresponding bin widths. The returned array has a shape of (2,N) where N
    # # is the number of wavelength bins, so that it can be easily unpacked in two separate arrays. The returned values
    # # are expressed in the specified units ('micron' by default). The function requires the presence of the
    # # "wavelength.dat" file. If this file is not found, the function raises an error.
    # def wavelengthbins(self, unit='micron'):
    #     filepath = self.outfilepath("wavelengths.dat")
    #     result = np.loadtxt(arch.opentext(filepath), usecols=(0,1), unpack=True)
    #     return self.units().convert(result, to_unit=unit, quantity='wavelength')
    #
    # ## This function returns a numpy array containing the luminosities of the SPH stellar particles imported for
    # # the simulation, specified for each wavelength bin. Thus the returned array is expected to have the same length
    # # as the wavelength grid. The returned values are expressed in the specified units ('Lsun' by default).
    # # The function requires the presence of the "luminosities.dat" file. If this file is not found, the function
    # # raises an error.
    # def stellarluminosities(self, unit='Lsun'):
    #     filepath = self.outfilepath("star_luminosities.dat")
    #     result = np.loadtxt(arch.opentext(filepath), usecols=(1,))
    #     return self.units().convert(result, to_unit=unit, quantity='luminosity')
    #
    # ## This function returns a numpy array containing the luminosities of the SPH HII region particles imported for
    # # the simulation, specified for each wavelength bin. Thus the returned array is expected to have the same length
    # # as the wavelength grid. The returned values are expressed in the specified units ('Lsun' by default).
    # # The function requires the presence of the "luminosities.dat" file. If this file is not found, the function
    # # raises an error.
    # def hiiregionluminosities(self, unit='Lsun'):
    #     filepath = self.outfilepath("hii_luminosities.dat")
    #     result = np.loadtxt(arch.opentext(filepath), usecols=(1,))
    #     return self.units().convert(result, to_unit=unit, quantity='luminosity')
    #
    # ## This function returns a numpy array containing the flux densities received by the specified instrument, at
    # # each wavelength bin center. Thus the returned array is expected to have the same length as the wavelength grid.
    # # The returned values are expressed in the specified units ('Jy' by default), with automatic conversion between
    # # flux styles (neutral, wavelength, frequency) as needed. The function requires the presence of the
    # # "prefix_name_sed.dat" file. If this file is not found, the function raises an error.
    # def fluxdensities(self, name, unit='Jy'):
    #     filepath = self.outfilepath(name + "_sed.dat")
    #     wavelengths, fluxes = np.loadtxt(arch.opentext(filepath), usecols=(0,1), unpack=True)
    #     wavelengths = self.units().convert(wavelengths, to_unit='micron', quantity='wavelength')
    #     return self.units().convert(fluxes, to_unit=unit, quantity='fluxdensity', wavelength=wavelengths)
    #

# -----------------------------------------------------------------
